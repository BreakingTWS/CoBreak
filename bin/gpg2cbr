#!/usr/bin/env ruby

=begin
Process GPG/PGP encrypted files into a format suitable for use with CoBreak.
This is CoBreak's own implementation for handling GPG/PGP encrypted files.

Author: BreakerTW
=end

require 'optparse'

class GPG2CoBreak
  GPG_MAGIC = "\x85\x01" # Marca de paquete nuevo GPG
  PGP_MAGIC = "\xa6\x00" # Marca de paquete viejo PGP

  # Tipos de paquetes GPG
  PKT_TYPES = {
    1  => "Public-Key Encrypted Session Key",
    2  => "Signature",
    3  => "Symmetric-Key Encrypted Session Key",
    4  => "One-Pass Signature",
    5  => "Secret Key",
    6  => "Public Key",
    7  => "Secret Subkey",
    8  => "Compressed Data",
    9  => "Symmetrically Encrypted Data",
    10 => "Marker",
    11 => "Literal Data",
    12 => "Trust",
    13 => "User ID",
    14 => "Public Subkey",
    18 => "Symmetrically Encrypted and MDC"
  }

  # Algoritmos de cifrado
  CIPHER_ALGOS = {
    1  => "IDEA",
    2  => "3DES",
    3  => "CAST5",
    4  => "Blowfish",
    7  => "AES-128",
    8  => "AES-192",
    9  => "AES-256",
    10 => "Twofish"
  }

  def initialize(options = {})
    @verbose = options[:verbose]
    @debug = options[:debug]
  end

  def read_packet_header(file)
    # Leer primer byte
    ptag = file.read(1)
    return nil unless ptag

    ptag = ptag.ord
    
    # Determinar si es formato nuevo o viejo
    new_format = (ptag & 0x40) != 0
    
    if new_format
      # Formato nuevo
      tag = (ptag & 0x3f)
      
      # Leer longitud
      len_type = file.read(1).ord
      if len_type < 192
        length = len_type
      elsif len_type < 224
        length = ((len_type - 192) << 8) + file.read(1).ord + 192
      elsif len_type == 255
        length = file.read(4).unpack('N')[0]
      else
        length = 1 << (len_type & 0x1f)
      end
    else
      # Formato viejo
      tag = (ptag >> 2) & 0x0f
      len_type = ptag & 0x03
      
      # Leer longitud
      case len_type
      when 0
        length = file.read(1).ord
      when 1
        length = file.read(2).unpack('n')[0]
      when 2
        length = file.read(4).unpack('N')[0]
      else
        length = nil # Longitud indeterminada
      end
    end

    {
      tag: tag,
      length: length,
      new_format: new_format
    }
  end

  def read_s2k_info(file)
    # Leer especificador S2K
    s2k_type = file.read(1).ord
    s2k_hash_algo = file.read(1).ord
    
    case s2k_type
    when 0 # Simple S2K
      salt = ""
      count = 0
    when 1 # Salted S2K
      salt = file.read(8)
      count = 0
    when 3 # Iterated and Salted S2K
      salt = file.read(8)
      count = file.read(1).ord
      count = (16 + (count & 15)) << ((count >> 4) + 6)
    else
      raise "Unknown S2K type: #{s2k_type}"
    end

    {
      type: s2k_type,
      hash_algo: s2k_hash_algo,
      salt: salt,
      count: count
    }
  end

  def pack_cobreak(packet_info, s2k_info, encrypted_data)
    # Formato CoBreak para GPG:
    # CB$GPG$algo$s2k_type$s2k_hash$salt$count$data
    [
      "CB$GPG$",
      packet_info[:cipher_algo].to_s,
      "$",
      s2k_info[:type].to_s,
      "$",
      s2k_info[:hash_algo].to_s,
      "$",
      s2k_info[:salt].unpack('H*').first,
      "$",
      s2k_info[:count].to_s,
      "$",
      encrypted_data.unpack('H*').first
    ].join + "\n"
  end

  def process_file(gpg_file)
    raise "File not found: #{gpg_file}" unless File.exist?(gpg_file)

    File.open(gpg_file, 'rb') do |file|
      while !file.eof?
        # Leer encabezado del paquete
        header = read_packet_header(file)
        break unless header

        puts "Found packet type: #{PKT_TYPES[header[:tag]]}" if @debug

        case header[:tag]
        when 3 # Symmetric-Key Encrypted Session Key Packet
          cipher_algo = file.read(1).ord
          s2k_info = read_s2k_info(file)
          encrypted_key = file.read(header[:length] - 2 - (s2k_info[:salt].length + 2))
          
          print pack_cobreak(
            { cipher_algo: cipher_algo },
            s2k_info,
            encrypted_key
          )
        when 9, 18 # Symmetrically Encrypted Data Packet
          encrypted_data = file.read(header[:length])
          puts "Found encrypted data (#{encrypted_data.length} bytes)" if @debug
        else
          # Saltar otros tipos de paquetes
          file.seek(header[:length], IO::SEEK_CUR) if header[:length]
        end
      end
    end
  rescue => e
    raise "Error processing GPG file: #{e.message}"
  end
end

if __FILE__ == $0
  options = {
    verbose: false,
    debug: false
  }

  parser = OptionParser.new do |opts|
    opts.banner = "Usage: #{$0} [options] <gpg-file>"
    
    opts.on("-v", "--verbose", "Show verbose output") do
      options[:verbose] = true
    end
    
    opts.on("-d", "--debug", "Show debug information") do
      options[:debug] = true
    end
    
    opts.on("-h", "--help", "Show this help message") do
      puts opts
      exit
    end
  end

  begin
    parser.parse!

    if ARGV.empty?
      puts parser
      exit 1
    end

    gpg_file = ARGV[0]
    converter = GPG2CoBreak.new(options)
    converter.process_file(gpg_file)

  rescue OptionParser::InvalidOption, OptionParser::MissingArgument
    puts parser
    exit 1
  rescue => e
    puts "Error: #{e.message}"
    exit 1
  end
end
